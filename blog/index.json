{"name":"posts","total":1,"result":[{"title":"Understanding Node - The Event Loop","layout":"post.html","date":"2015-07-28T00:00:00.000Z","author":"Diego Mónaco","tags":["Javascript","NodeJS"],"draft":false,"contents":"<p>Node processes JavaScript instructions using a single thread (using the <a href=\"https://developers.google.com/v8\">V8 JavaScript engine</a>), this means that your Node program will execute only one operation at a time, so in order to achieve concurrency, Node uses a bunch of threads running behind the scenes to manage asynchronous I/O tasks (among other things), these operations generate events that end up executing callback functions into the aforementioned single thread of Javascript.</p>\n<p>The event loop is in charge to poll for I/O events and coordinate the execution of all these callbacks, building up and tearing down a single stack on each iteration.</p>\n<p>So how these stacks are built?</p>\n<p>When a Node process executes the input script some instructions may express interest on future events by registering a function to be called when the associated event occurs, after this first stack finishes running, the event loop will start walking through a series of steps synchronously invoking callbacks based on his <a href=\"http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop\">internal algorithm</a>, when the last function on the current iteration returns Node starts the cycle again to run the next &quot;tick&quot; of Javascript code, this loop keeps running until there are no more events to handle and therefore no more callbacks to run.</p>\n<h1 id=\"callback-types\">Callback Types</h1>\n<p>There are four kind of callbacks that can be registered for future execution:</p>\n<h2 id=\"i-o-callbacks-\">I/O callbacks:</h2>\n<p>All I/O operations are consistently implemented as asynchronous, evented data streams, the event loop will poll the OS on every iteration to check for I/O events ready to be handled and will run the corresponding callbacks if any.</p>\n<h2 id=\"timer-callbacks-\">Timer callbacks:</h2>\n<p>Callbacks to be executed sometime in the future specified in milliseconds, Node timers are not interrupts, they simply promise to execute as close as possible to the specified time, though never before. You can run a one-time callback after a specific delay or you can schedule a callback to be executed periodically based on a time interval.</p>\n<p><a href=\"https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg\"><code>global.setTimeout</code></a>  </p>\n<p><a href=\"https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_arg\"><code>global.setInterval</code></a></p>\n<h2 id=\"immediate-callbacks-\">Immediate callbacks:</h2>\n<p>Immediate callbacks won&#39;t fire until the next event loop iteration and after all I/O processing. Callbacks for immediates are queued in the order in which they were created.</p>\n<p><a href=\"https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg\"><code>global.setImmediate</code></a></p>\n<h2 id=\"next-tick-callbacks-\">Next Tick callbacks:</h2>\n<p>Next Tick callbacks are run right after each call from C++ into JavaScript. It means that these callbacks will fire as soon as the current stack runs to completion, <strong>before going back to the event loop</strong>, this ensures that they always run before any further I/O processing.</p>\n<p><a href=\"https://nodejs.org/api/process.html#process_process_nexttick_callback_arg\"><code>process.nextTick</code></a></p>\n<p><em>* Names are very missleading here as global.setImmediate is on the next “tick”, and process.nextTick is “immediate”</em></p>\n<h1 id=\"callback-execution-order\">Callback execution order</h1>\n<p>On each iteration of the event loop callbacks are run in the following order:</p>\n<ol>\n<li><p><strong>Run initial script</strong> </p>\n<p>-&gt;  <strong>Run Next Tick callbacks.</strong></p>\n</li>\n<li><p><strong>Run Timer callbacks:</strong> All active timers scheduled for a time before the loop’s concept of now get their callbacks called.</p>\n<p>-&gt;  <strong>Run Next Tick callbacks.</strong></p>\n</li>\n<li><p><strong>Run Pending I/O callbacks:</strong> If the previous iteration deferred any I/O callback it will be run at this point.</p>\n<p>-&gt;  <strong>Run Next Tick callbacks.</strong></p>\n</li>\n<li><p><strong>Run Current I/O callbacks:</strong> At this point the loop will block for I/O for the timeout calculated on a previous step. All I/O related handles that were monitoring a given file descriptor for a read or write operation get their callbacks called at this point.</p>\n<p>-&gt;  <strong>Run Next Tick callbacks.</strong></p>\n</li>\n<li><p><strong>Run Immediate callbacks:</strong> The entire callback queue is processed every event loop iteration.</p>\n<p>-&gt;  <strong>Run Next Tick callbacks.</strong></p>\n</li>\n<li><p><strong>Go to step 2:</strong> Start new cycle</p>\n</li>\n</ol>\n<p>Understanding this, we can clearly see that the entire program can be blocked by JavaScript code because while a call stack is being unrolled no other events can be handled, so it&#39;s the developer task to ensure that the call stack always executes as fast as possible.</p>\n<h1 id=\"code-time\">Code time</h1>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n<span class=\"hljs-keyword\">var</span> tickNumber = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">var</span> executionOrder = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printExecutionOrder</span>(<span class=\"hljs-params\">caller</span>) </span>{\n  ++executionOrder;\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Tick: '</span> + tickNumber + <span class=\"hljs-string\">' #'</span> + executionOrder + <span class=\"hljs-string\">': '</span> + caller);\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">regularCall</span>(<span class=\"hljs-params\">regularCallNumber</span>) </span>{\n  printExecutionOrder(<span class=\"hljs-string\">'regular call '</span> + regularCallNumber);\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">timeOutCall</span>(<span class=\"hljs-params\"></span>) </span>{\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    printExecutionOrder(<span class=\"hljs-string\">'setTimeout'</span>);\n  }, <span class=\"hljs-number\">1</span>);\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">nextTickCall</span>(<span class=\"hljs-params\"></span>) </span>{\n  process.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    executionOrder = <span class=\"hljs-number\">0</span>;\n    ++tickNumber;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'----------------------'</span>);\n    printExecutionOrder(<span class=\"hljs-string\">'nextTick'</span>);\n  });\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setImmediateCall</span>(<span class=\"hljs-params\"></span>) </span>{\n  setImmediate(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    printExecutionOrder(<span class=\"hljs-string\">'setImmediate'</span>);\n    nextTickCall();\n  });\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setIntervalCall</span>(<span class=\"hljs-params\"></span>) </span>{\n  setInterval(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    printExecutionOrder(<span class=\"hljs-string\">'setInterval'</span>);\n  }, <span class=\"hljs-number\">1</span>).unref();\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ioCall</span>(<span class=\"hljs-params\"></span>) </span>{\n  fs.stat(__filename, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    printExecutionOrder(<span class=\"hljs-string\">'I/O'</span>);\n  });\n};\n\nprocess.on(<span class=\"hljs-string\">'exit'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'etc, etc....'</span>);\n});\n\nsetIntervalCall();\n\nregularCall(<span class=\"hljs-string\">'1'</span>);\n\ntimeOutCall();\n\nregularCall(<span class=\"hljs-string\">'2'</span>);\n\nnextTickCall();\n\nregularCall(<span class=\"hljs-string\">'3'</span>);\n\nsetImmediateCall();\n\nregularCall(<span class=\"hljs-string\">'4'</span>);\n\nioCall();\n</code></pre>\n<p>Running this script we can see that all the regular function calls are runned in sequencial order, and the execution order for the registered callbacks is exactly what we explained before:</p>\n<pre><code class=\"hljs bash\">$ node event_loop.js\n\nTick: <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">#1: regular call 1</span>\nTick: <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">#2: regular call 2</span>\nTick: <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">#3: regular call 3</span>\nTick: <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">#4: regular call 4</span>\n----------------------\nTick: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">#1: nextTick</span>\nTick: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">#2: setInterval</span>\nTick: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">#3: setTimeout</span>\nTick: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">#4: I/O</span>\nTick: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">#5: setImmediate</span>\n----------------------\nTick: <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">#1: nextTick</span>\nTick: <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">#2: setInterval</span>\netc, etc....\n</code></pre>\n","excerpt":"Node processes JavaScript instructions using a single thread (using the V8 JavaScript engine), this means that your Node program will execute only one operation…","path":"blog/understanding-node-the-event-loop","tagsUrlSafe":["Javascript","NodeJS"]}],"type":"list"}